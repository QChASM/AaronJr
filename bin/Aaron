#!/usr/bin/env python3
import os
from math import exp
from time import sleep
from warnings import warn

from Aaron.job import LAUNCHPAD, Job
from AaronTools.config import Config
from AaronTools.const import AARONLIB, PHYSICAL, UNIT
from AaronTools.geometry import Geometry
from fabric import Connection
from prettytable import PrettyTable


def monitor(fw_id, verbose=False):
    workflow = LAUNCHPAD.get_wf_by_fw_id(fw_id)
    fw = LAUNCHPAD.get_fw_by_id(fw_id)
    job = Job(fw)
    if verbose or fw.state not in ["WAITING"]:
        print("{:10} {:10} {}".format(fw.fw_id, fw.state, fw.name))
    if fw.state in ["RUNNING", "COMPLETED"]:
        job.transfer_output()
        try:
            output = job.validate()
            if fw.state == "RUNNING":
                print(output.get_progress())
        except OSError as e:
            warn("Issue validating computational output")
            warn(str(e))
            warn("Trying to rerun firework")
            LAUNCHPAD.rerun_fw(fw.fw_id)
            return False
    if fw.state == "COMPLETED":
        for child in workflow.links[fw.fw_id]:
            child = LAUNCHPAD.get_fw_by_id(child)
            if child.state in ["READY", "WAITING"]:
                child = Job(child)
                child.update_structure(output.geometry)
        if output.finished:
            return True
    if fw.state == "DEFUSED":
        if len(fw.archived_launches) > 10:
            return True
        job.resolve_error()
    if fw.state == "READY":
        job.write()
        job.launch_job()
    return False


def one_job(args, template, config, job_type=None, submit=True):
    all_jobs = []
    all_changes = []
    all_fws = []
    if not config._changes:
        config._changes = {"": ({}, None)}
    for name, (changes, kind) in config._changes.items():
        structure = template.copy()
        if kind is not None and name:
            structure.name = os.path.join(name, structure.name)
        this_config = Config(args.config, quiet=True)
        if ["include"] not in this_config["Job"]:
            if job_type == "ts":
                this_config["Job"]["include"] = "TS"
            elif job_type == "min":
                this_config["Job"]["include"] = "Minimum"
        this_config._parse_includes()
        this_config["Job"]["name"] = structure.name
        parent = None
        for i, ac in enumerate(all_changes):
            for c in changes:
                if c in ac and ac[c] == changes[c]:
                    del changes[c]
                    break
            else:
                continue
            parent = all_jobs[i].fw_id
            structure.atoms = all_jobs[i].structure.atoms
            break
        this_config._changes = {name: (changes, kind)}
        job = Job(structure, this_config, quiet=args.quiet)
        if args.show:
            job.structure.write()
            os.system("chimera {}.xyz".format(job.structure.name))
            print(job.structure)
            ans = input("Starting structure OK? (Y/n) ")
            if ans.lower() in ["n", "no"]:
                exit(2)
        if submit:
            fws = job.add_workflow(parent_fw_id=parent)
        else:
            fws = [job]
            if job.step_list:
                job._root_fw()
        all_changes += [changes]
        all_jobs += [job]
        all_fws += fws
    return set(all_fws)


def get_table(args, results, min_val, config):
    temperature = float(config["Job"]["temperature"])
    percents = ["%"]
    if "selectivity" in config["Reaction"]:
        percents = [
            "% {}".format(s.strip())
            for s in config["Reaction"]["selectivity"].split(",")
        ]

    table = PrettyTable()
    table.field_names = (
        ["structure"] + list(min_val.keys()) + ["rel rate", "prod ratio"]
    )
    for name in results:
        output = results[name]
        row = [name]
        for key in min_val.keys():
            if output is None:
                row += ["---"]
                continue
            val = getattr(output, key) - min_val[key]
            val *= UNIT.HART_TO_KCAL
            row += [val]
        val = row[-1]
        # relative rates
        if isinstance(val, float):
            row += [exp(-val / PHYSICAL.R / temperature)]
        else:
            row += ["---"]
        row += [""] * (len(table._field_names) - len(row))
        table.add_row(row)
    # product ratios
    idx = table._field_names.index("prod ratio")
    for row in table._rows:
        if isinstance(row[idx - 1], float):
            row[idx] = row[idx - 1] / min(
                [
                    r[idx - 1]
                    for r in table._rows
                    if isinstance(r[idx - 1], float)
                ]
            )
        else:
            row[idx] = "---"
    # percents
    idx += 1
    if len(percents) == 1 and percents[0] == "%":
        for row in table._rows:
            if isinstance(row[idx - 1], float):
                row[idx] = (
                    100
                    * row[idx - 1]
                    / sum(
                        [
                            r[idx - 1]
                            for r in table._rows
                            if isinstance(r[idx - 1], float)
                        ]
                    )
                )
            else:
                row[idx] = "---"
    else:
        done = dict(zip(percents, [False for p in percents]))
        table._rows = sorted(table._rows, key=lambda x: x[0])
        for i, p in enumerate(percents):
            if done[p]:
                continue
            done[p] = True
            val_sum = 0
            for row in table._rows:
                sel = p.lstrip("% ")
                if isinstance(row[idx - 1], float) and row[0].startswith(sel):
                    val_sum += (
                        100
                        * row[idx - 1]
                        / sum(
                            [
                                r[idx - 1]
                                for r in table._rows
                                if isinstance(r[idx - 1], float)
                            ]
                        )
                    )
            table.add_column(p, [val_sum] + [""] * (len(table._rows) - 1))
    return table


def show_results(args, jobs):
    min_dict = {args.thermo: None}
    all_results = {}
    for job in jobs:
        head, tail = os.path.split(job.structure.name)
        all_results.setdefault(
            tail,
            ({}, min_dict.copy(), job.config_for_step()),
        )
        results, min_val, temperature = all_results[tail]
        job.step = job.get_steps()[-1]
        try:
            output = job.validate()
        except FileNotFoundError:
            results[job.structure.name] = None
            continue
        results[job.structure.name] = output
        for key in min_val.keys():
            val = getattr(output, key)
            if min_val[key] is None or min_val[key] > val:
                min_val[key] = val
    table = PrettyTable()
    for name, (results, min_val, config) in all_results.items():
        tmp = get_table(args, results, min_val, config)
        for row in sorted(tmp._rows, key=lambda x: x[0]):
            table.add_row(row)
        table.add_row([""] * len(row))
    table.field_names = tmp._field_names
    table.align = "r"
    table.align["structure"] = "l"
    table.float_format = "0.1"
    if not args.csv:
        print(table)
    else:
        rv = ",".join(table._field_names) + "\n"
        for row in table._rows:
            for i, r in enumerate(row):
                if r == "---":
                    row[i] = ""
            rv += ",".join(row) + "\n"
        print(rv)


def main(args):
    config = Config(args.config, quiet=args.quiet)
    config.parse_functions()
    all_fws = set([])
    try:
        template = config.get_template()
    except FileNotFoundError as e:
        if args.results:
            return
        else:
            raise e
    if isinstance(template, Geometry):
        all_fws = one_job(args, template, config, submit=not args.results)
    else:
        for template, kind in config.get_template():
            all_fws = all_fws.union(
                one_job(
                    args,
                    template,
                    config,
                    job_type=kind,
                    submit=not args.results,
                )
            )
    skip_fws = set([])
    if args.results:
        show_results(args, all_fws)
        return
    verbose = not args.quiet
    while True:
        for fw in all_fws:
            if fw in skip_fws:
                continue
            if monitor(fw, verbose=verbose):
                skip_fws.add(fw)
        if len(skip_fws) != len(all_fws):
            if not verbose:
                sleep(30)
            os.system("clear")
        else:
            break
        verbose = False


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        "config",
        nargs="?",
        type=str,
        metavar="path/to/file",
        default="config.ini",
        help="computational configuration file",
    )
    parser.add_argument(
        "--quiet", action="store_true", help="turn off status messages"
    )
    parser.add_argument(
        "--show", action="store_true", help="show structure before submitting"
    )
    parser.add_argument(
        "--results",
        action="store_true",
        help="only show results (don't submit anything)",
    )
    parser.add_argument(
        "--csv", action="store_true", help="print results in csv format"
    )
    parser.add_argument(
        "--thermo",
        nargs="?",
        type=str,
        help="Select thermodynamic property to use",
        metavar="energy|enthalpy|free_energy",
        default="free_energy",
    )
    args = parser.parse_args()
    main(args)
